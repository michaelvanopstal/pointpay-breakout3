<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bitcoin Knight Animatie</title>
  <style>
    body {
      background: #000;
      color: #fff;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 18px;
    }
    canvas {
      background: transparent;
      display: block;
      border-radius: 6px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.6);
    }
    .controls {
      display: flex;
      gap: 8px;
    }
    button {
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      border-radius: 6px;
      border: none;
      background: #1f7;
      color: #000;
    }
    button.secondary {
      background: #3a3a3a;
      color: #fff;
    }
  </style>
</head>
<body>
  <h2>Bitcoin Knight Animatie</h2>
  <canvas id="c" width="800" height="800"></canvas>
  <div class="controls">
    <button id="play">Speel animatie</button>
    <button id="stop" class="secondary">Stop</button>
  </div>
  <p>Tip: zet de afbeelding <strong>knight.png</strong> naast deze index.html.</p>

<script>
// ====== INSTELLINGEN ======
const imgSrc = 'knight.png'; // <-- zorg dat jouw plaatje zo heet en in dezelfde map staat

// geschatte posities (je kunt later fine tunen)
const config = {
  leftEye:  { x: 320, y: 360, pupilR: 8 },
  rightEye: { x: 392, y: 360, pupilR: 8 },
  swordTip: { x: 700, y: 40 },

  // stuk waar het zwaard in zit in de originele afbeelding
  swordCrop: { x: 540, y: 0, w: 220, h: 280 },
  // rotatiepunt van het zwaard (waar de hand is) binnen die crop
  swordPivotInCrop: { x: 30, y: 180 },

  timings: {
    lookDuration: 700,
    holdAfterLook: 300,
    swingCount: 3,
    swingDurationEach: 280,
    restDuration: 600
  }
};
// ===========================

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let img = new Image();
let imgLoaded = false;
let offSwordCanvas = null;
let playing = false;
let sequence = [];
let currentSwordAngle = 0;
let pupilOffsets = { L:{x:0,y:0}, R:{x:0,y:0} };
let coverSwordBBox = null;

// afbeelding laden
img.onload = () => {
  imgLoaded = true;
  setupSwordCrop();
  drawStatic();
};
img.onerror = () => {
  console.error('Kon knight.png niet laden. Staat hij wel naast index.html?');
};
img.src = imgSrc;

// zwaard uitknippen
function setupSwordCrop() {
  const sc = config.swordCrop;
  const c = document.createElement('canvas');
  c.width = sc.w;
  c.height = sc.h;
  const cx = c.getContext('2d');
  cx.drawImage(img, sc.x, sc.y, sc.w, sc.h, 0, 0, sc.w, sc.h);
  offSwordCanvas = c;

  // iets ruimer vlak om het originele zwaard te bedekken
  coverSwordBBox = {
    x: sc.x - 6,
    y: sc.y - 6,
    w: sc.w + 12,
    h: sc.h + 12
  };
}

function drawStatic() {
  if (!imgLoaded) return;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  drawEyes({L:{x:0,y:0},R:{x:0,y:0}});
}

function sourceToCanvasScale() {
  return {
    sx: canvas.width / img.width,
    sy: canvas.height / img.height
  };
}

function drawEyes(p) {
  const { sx, sy } = sourceToCanvasScale();
  const L = config.leftEye;
  const R = config.rightEye;

  ctx.save();
  // linker pupil
  ctx.beginPath();
  ctx.fillStyle = '#000';
  ctx.arc(L.x * sx + p.L.x, L.y * sy + p.L.y, L.pupilR * ((sx+sy)/2), 0, Math.PI*2);
  ctx.fill();
  // rechter pupil
  ctx.beginPath();
  ctx.fillStyle = '#000';
  ctx.arc(R.x * sx + p.R.x, R.y * sy + p.R.y, R.pupilR * ((sx+sy)/2), 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

function drawRotatedSword(angle) {
  if (!offSwordCanvas) return;
  const { sx, sy } = sourceToCanvasScale();

  const pivot = {
    x: (config.swordCrop.x + config.swordPivotInCrop.x) * sx,
    y: (config.swordCrop.y + config.swordPivotInCrop.y) * sy
  };

  const w = offSwordCanvas.width * sx;
  const h = offSwordCanvas.height * sy;

  ctx.save();
  ctx.translate(pivot.x, pivot.y);
  ctx.rotate(angle);
  ctx.drawImage(
    offSwordCanvas,
    0, 0, offSwordCanvas.width, offSwordCanvas.height,
    -config.swordPivotInCrop.x * sx,
    -config.swordPivotInCrop.y * sy,
    w, h
  );
  ctx.restore();
}

function lerp(a,b,t){ return a + (b-a)*t; }
function degToRad(d){ return d * Math.PI / 180; }
function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

function computePupilOffsetsForTarget(tx, ty, max=7) {
  const { sx, sy } = sourceToCanvasScale();
  const Lc = { x: config.leftEye.x * sx, y: config.leftEye.y * sy };
  const Rc = { x: config.rightEye.x * sx, y: config.rightEye.y * sy };

  function offs(eye) {
    const dx = tx - eye.x;
    const dy = ty - eye.y;
    const a = Math.atan2(dy, dx);
    return { x: Math.cos(a)*max, y: Math.sin(a)*max };
  }
  return { L: offs(Lc), R: offs(Rc) };
}

function buildSequence(start) {
  const t = config.timings;
  sequence = [];
  let time = 0;

  sequence.push({ name:'look', t0:time, t1: time + t.lookDuration });
  time += t.lookDuration;
  sequence.push({ name:'holdLook', t0:time, t1: time + t.holdAfterLook });
  time += t.holdAfterLook;
  for (let i=0; i<t.swingCount; i++) {
    sequence.push({ name:'swing', idx:i, t0:time, t1: time + t.swingDurationEach });
    time += t.swingDurationEach;
  }
  sequence.push({ name:'rest', t0:time, t1: time + t.restDuration });
  time += t.restDuration;

  sequence.total = time;
  sequence.start = start;
}

function animate(now) {
  if (!playing) return;
  const local = now - sequence.start;

  if (local > sequence.total) {
    // klaar
    drawStatic();
    playing = false;
    return;
  }

  // basis tekenen
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  const { sx, sy } = sourceToCanvasScale();
  const swordTipCanvas = { x: config.swordTip.x * sx, y: config.swordTip.y * sy };

  // welke fase?
  let phase = null;
  for (const ph of sequence) {
    if (local >= ph.t0 && local < ph.t1) {
      phase = ph;
      phase.progress = (local - ph.t0) / (ph.t1 - ph.t0);
      break;
    }
  }

  if (!phase) {
    drawEyes({L:{x:0,y:0}, R:{x:0,y:0}});
    requestAnimationFrame(animate);
    return;
  }

  if (phase.name === 'look') {
    const targ = computePupilOffsetsForTarget(swordTipCanvas.x, swordTipCanvas.y, 8);
    pupilOffsets.L.x = lerp(0, targ.L.x, easeOutCubic(phase.progress));
    pupilOffsets.L.y = lerp(0, targ.L.y, easeOutCubic(phase.progress));
    pupilOffsets.R.x = lerp(0, targ.R.x, easeOutCubic(phase.progress));
    pupilOffsets.R.y = lerp(0, targ.R.y, easeOutCubic(phase.progress));
    drawEyes(pupilOffsets);
  }
  else if (phase.name === 'holdLook') {
    pupilOffsets = computePupilOffsetsForTarget(swordTipCanvas.x, swordTipCanvas.y, 8);
    drawEyes(pupilOffsets);
  }
  else if (phase.name === 'swing') {
    // zwaardgebied bedekken
    ctx.fillStyle = '#000';
    ctx.fillRect(
      coverSwordBBox.x * sx,
      coverSwordBBox.y * sy,
      coverSwordBBox.w * sx,
      coverSwordBBox.h * sy
    );

    const swingIndex = phase.idx;
    const maxAngle = degToRad(28) * (1 - swingIndex * 0.12);
    const angle = Math.sin(phase.progress * Math.PI) * ((swingIndex % 2 === 0) ? -maxAngle : maxAngle);
    currentSwordAngle = angle;
    drawRotatedSword(currentSwordAngle);

    // ogen volgen zwaardpunt
    const pivot = {
      x: (config.swordCrop.x + config.swordPivotInCrop.x) * sx,
      y: (config.swordCrop.y + config.swordPivotInCrop.y) * sy
    };
    const tipRel = {
      x: (config.swordCrop.w - config.swordPivotInCrop.x) * sx,
      y: (0 - config.swordPivotInCrop.y) * sy
    };
    const tipRot = {
      x: pivot.x + (tipRel.x * Math.cos(currentSwordAngle) - tipRel.y * Math.sin(currentSwordAngle)),
      y: pivot.y + (tipRel.x * Math.sin(currentSwordAngle) + tipRel.y * Math.cos(currentSwordAngle))
    };
    const pOff = computePupilOffsetsForTarget(tipRot.x, tipRot.y, 9);
    drawEyes(pOff);
  }
  else if (phase.name === 'rest') {
    // zwaard terug naar boven
    ctx.fillStyle = '#000';
    ctx.fillRect(
      coverSwordBBox.x * sx,
      coverSwordBBox.y * sy,
      coverSwordBBox.w * sx,
      coverSwordBBox.h * sy
    );
    const ang = lerp(currentSwordAngle, 0, easeOutCubic(phase.progress));
    drawRotatedSword(ang);

    // ogen naar neutraal
    pupilOffsets.L.x = lerp(pupilOffsets.L.x, 0, phase.progress);
    pupilOffsets.L.y = lerp(pupilOffsets.L.y, 0, phase.progress);
    pupilOffsets.R.x = lerp(pupilOffsets.R.x, 0, phase.progress);
    pupilOffsets.R.y = lerp(pupilOffsets.R.y, 0, phase.progress);
    drawEyes(pupilOffsets);
  }

  requestAnimationFrame(animate);
}

// knoppen
document.getElementById('play').addEventListener('click', () => {
  if (!imgLoaded) {
    alert('Afbeelding (knight.png) is nog niet geladen.');
    return;
  }
  if (playing) return;
  playing = true;
  buildSequence(performance.now());
  requestAnimationFrame(animate);
});

document.getElementById('stop').addEventListener('click', () => {
  playing = false;
  drawStatic();
});
</script>
</body>
</html>

